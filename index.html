<!DOCTYPE html>
<html>
	<head>
		<title>Game</title>
		<meta charset="utf-8"/>
		<script src="nimble.js" type="text/javascript"></script>
		<script src="pixi.js" type="text/javascript"></script>
		<script src="gm.js" type="text/javascript"></script>
	</head>
	<body>
		<script type="text/javascript">
/*
	This is a game created for testing GM-JS
	Version 1.3.2
*/
oncontextmenu = function(){return false;};
window.onload = function(){'use strict';
	
	
	//Setup Sprites
var Sprites = [{path:'images/sprites.png', strip:[{name:'spr_character', animated:{count:12,columns:6,w:64,h:64}},
	{name:'spr_enemy', animated:{count:12,columns:6,w:64,h:64}}]},
	{name:'spr_treasure', path:'images/treasurebox.png'},
	//{path:'images/sprites.png', strip:[{name:'spr_enemy', tile:{x:0,y:0,w:64,h:64}}, {name:'spr_character', tile:{x:0,y:64,w:64,h:64}}]},
	{name:'spr_wall', path:'images/wall.png'},
	{name:'spr_shield', path:'images/shield.png'},
	{name:'spr_health', path:'images/health.png'},
	{name:'spr_bullet', path:'images/bullet.png'}];
	
	if(typeof(GMJS) == 'object'){
		GMJS.StartGameEngine({
			onStart:GameInit,
			images:Sprites,
			view:{width:512, height:416}
		});
	} else return console.error('GMJS not found');
	
	var g = GMJS;
	
	function draw_bar(g, x, y, color, life, full, width){
		width = width || 32;
		full = full || 100;
		color.border = ('border' in color)?color.border:0XFFFFFF;
		color.fill = ('fill' in color)?color.fill:0X000000;
		g.lineStyle(1, color.border);
		g.drawRect(x - width/2, y, width, 8);
		g.lineStyle(0);
		g.beginFill(color.fill);
		g.drawRect(x - width/2, y, width*life/full, 8);
		g.endFill();
	}
	
	function GameInit(){
		//Setup Fonts
		var PlayerFont = g.create_text_style({fontFamily: 'Arial', fontSize: 10, fill:0xFFFFFF});
		//Setup Objects
		var Cont = new g.object({
				name:'controller',
				creation:function(t){
					t.draw_kills = g.create_text('', 8, 8, PlayerFont);
						t.draw_kills.align('top', 50);
						t.draw_kills.depth = -2;
					t.create_item.time = 60 + Math.random()*100;
					t.create_player.time = 50;//create player first
					t.create_enemy.time = 100;
					t.kills = 0;
					t.player = null;
				},
				step:function(t){
					t.graphics.beginFill(0X444444);
					t.graphics.drawRect(0, 0, 128, 16);
					if(t.player){
						t.draw_kills.text = 'Kills: ' + t.kills.toString() + '  Points: '+t.player.points.toString();
					}
					if(g.mouse_check_pressed() && g.keyboard.shift){
						var xx = g.mouse.x,
						yy = g.mouse.y;
						Wall.instance_create(Math.round(xx/32)*32, Math.round(yy/32)*32);
					}
				},
				alarms:[
				{name:'create_item', code:function(t){var item = ([TreasureBox, HealthItem, ShieldItem])[Math.round(Math.random()*2)]; item.instance_create(Math.random()*g.room.width,Math.random()*g.room.height);t.create_item.time = 10*t.player.points + 100*(ItemObjects.instance_number() + 1) + Math.random()*100;}},
				{name:'create_player', code:function(t){t.player = Character.instance_create(g.room.width/2, g.room.height/2);}},
				{name:'create_enemy', code:function(t){
					do {var xx = 64 + Math.random()*(g.room.width - 128), yy = 64 + Math.random()*(g.room.height - 128);
					} while (g.collision_point(xx, yy, 'collision_objects'));
					Enemy.instance_create(xx, yy);t.create_enemy.time = Math.max(100 + Math.random()*(1500 - t.kills), 50);}}
				]
			});
		var GatherObjects = new g.object({
				name:'gather_objects'
			});
		var CollisionObjects = new g.object({
			name:'collision_objects',
			parent:GatherObjects
		});
		var ItemObjects = new g.object({
			name:'ItemPar',
			mask:{x:0, y:0, w:8, h:8},
			creation:function(t){
				t.depth = g.room.height - t.y;
				t.image_alpha = 0;
				t.xscale = 0.5;
				t.yscale = 0.5;
			},
			step:function(t){
				if(t.image_alpha < 1) t.image_alpha += 0.02;
			},
			collision:[{object:GatherObjects, code:function(t,other){if(t.image_alpha >= 1 || other.object_index == Wall)t.instance_destroy();}}]
		});
		var Bullet = new g.object({
				name:'Bullet',
				image:'spr_bullet',
				mask:{x:0,y:0,w:8,h:8},
				creation:function(t){
					t.xscale = 0.25;
					t.yscale = 0.25;
					t.spd = 8;
					t.image_alpha = 0;
					t.dir = [0,0,0,0];//lrud
				},
				step:function(t){
					t.image_angle = (t.dir[0])?-90 + 45*t.dir[2] - 45*t.dir[3]:45*t.dir[1] - 45*t.dir[0];
					if(t.dir[3]){
						t.image_angle = 180 - 45*t.dir[1] + 45*t.dir[0];
					}
					if(t.dir[1]){
						t.image_angle = 90 - 45*t.dir[2] + 45*t.dir[3];
					}
					if(t.image_alpha < 1) t.image_alpha += 0.25;
					t.depth = g.room.height - t.y;
					if(t.dir[0]) t.x -= t.spd;
					if(t.dir[1]) t.x += t.spd;
					if(t.dir[2]) t.y -= t.spd;
					if(t.dir[3]) t.y += t.spd;
				},
				collision:[
					{object:CollisionObjects, code:function(t, other){
						t.instance_destroy();
					}}
				]
			});
		var TreasureBox = new g.object({
				name:'TreasureBox',
				image:'spr_treasure',
				parent:ItemObjects
			});
		var HealthItem = new g.object({
				name:'Health',
				image:'spr_health',
				parent:ItemObjects
			});
		var ShieldItem = new g.object({
				name:'Shield',
				image:'spr_shield',
				parent:ItemObjects
			});
		var Enemy = new g.object({
			image:'spr_enemy',
			name:'Enemy',
			parent:GatherObjects,
			creation:function(t){
				t.health = 100;
				t.xscale = 0.5;
				t.yscale = 0.5;
				t.reset_keys = function(){					
					t.left = false;
					t.right = false;
					t.up = false;
					t.down = false;
				}
				t.reset_keys();
				t.reset_motion.time = 10;
				t.image_alpha = 0;
				t.spd = 2;
				t.image_single = Math.round(Math.random()*5);
				t.power = t.image_single + 1;
			},
			destroyed:function(t){
				Cont.instances[0].kills++;
			},
			step:function(t){
				t.depth = g.room.height - t.y;
				t.graphics.depth = t.depth - 1;
				if(t.image_alpha >= 1){
					draw_bar(t.graphics, t.x, t.y - t.sprite.height/2 - 10, {border:0x600000, fill:0XDD0000}, t.health);
				}
				
				if(t.image_alpha < 1) t.image_alpha += 0.1;
				if(t.up){t.y -= t.spd;}
				if(t.down){t.y += t.spd;}
				if(t.left){t.x -= t.spd;}
				if(t.right){t.x += t.spd;}
			},
			alarms:[
				{name:'reset_motion', code:function(t){
					t.reset_keys();
					t.left = Math.round(Math.random());
					t.right = Math.round(Math.random());
					t.up = Math.round(Math.random());
					t.down = Math.round(Math.random());
					t.reset_motion.time = 80 + Math.random()*100;
				}}
			],
			collision:[
				{object:CollisionObjects, code:g.collision_bounce},
				{object:Bullet, code:function(t, other){
					other.instance_destroy();
					t.health-= (10 + Math.random(20))/t.power;
					if(t.health < 0) {t.health = 0;t.instance_destroy();}
				}}, {object:ItemObjects, code:function(t, other){
					if(other.image_alpha < 1) return;
					switch(other.object_index){
						case TreasureBox: break;
						case HealthItem: t.health = Math.min(t.health + 25, 100);break;
						case ShieldItem: break;
					}
				}}
			]
		});	
		var Wall = new g.object({
			name:'Wall',
			image:'spr_wall',
			parent:CollisionObjects,
			creation:function(t){
				t.depth = g.room.height - t.y;
			}
		});
		var Character = new g.object({
			name:'Character',
			image:'spr_character',
			mask:{x:0,y:0,radius:16},
			parent:GatherObjects,
			creation:function(t){
				console.log(t);
				t.image_single = 6;
				t.points = 0;
				t.health = 100;
				t.shield = 50; //steps for invincibility after hit
				t.reset_hit_rate = function(){t.image_alpha = t.hit;t.hit = false;t.flash = 0;t.hit_rate = Math.round(t.shield);}
				t.reset_hit_rate();
				t.spd = 3;
				t.xscale = 0.5;
				t.yscale = 0.5;
				t.up = false;t.down = false;t.left = false;t.right = false;
				t.last_dir = [0,1,0,0]; //[left, right, up, down]
			},
			step:function(t){
				if(t.hit){
					t.image_alpha = t.flash;
				}
				if(t.health <= 0){
					t.instance_destroy();
					g.With(Cont, function(tt){
						tt.create_player.time = 100;
					});
					return;
				}
				t.depth = g.room.height - t.y;
				t.graphics.depth = t.depth - 1;
				t.up = g.keyboard.up;
				t.down = (g.keyboard.down && !t.up);
				t.left = g.keyboard.left;
				t.right = (g.keyboard.right && !t.left);
				if(t.left || t.right || t.up || t.down) t.last_dir = [t.left, t.right, t.up, t.down];
				if(t.up){t.y -= t.spd;}
				if(t.down){t.y += t.spd;}
				if(t.left){t.x -= t.spd;}
				if(t.right){t.x += t.spd;}
				if(g.keyboard_check_pressed('control')){
					var ii=Bullet.instance_create(t.x + (t.last_dir[0]*-16) + (t.last_dir[1]*16), t.y + (t.last_dir[2]*-16) + (t.last_dir[3]*16));
					ii.dir = [].concat(t.last_dir);
				}
			},
			end_step:function(t){
				draw_bar(t.graphics, t.x, t.y - t.sprite.height/2 - 10, {border:0x007700, fill:(t.health<60)?((t.health<30)?((t.health<15)?0X770000:0XDD0000):0XDDDD00):0X00DD00}, t.health);
				draw_bar(t.graphics, t.x, t.y - t.sprite.height/2 - 20, {border:0x005959, fill:0X0000F1}, t.shield, 50);
			},
			collision:[
				{object:CollisionObjects, code:g.collision_bounce},
				{object:ItemObjects, code:function(t, other){
					if(other.image_alpha < 1) return;
					switch(other.object_index){
						case TreasureBox: t.points ++;break;
						case HealthItem: t.health = Math.min(t.health + 25, 100);break;
						case ShieldItem: t.shield = Math.min(t.shield + 10, 50);break;
					}
				}},
				{object:Enemy, code:function(t, other){
					if(!t.hit){
						t.hit = true;
						t.hit_flash.time = 5;
						t.health-= (1 + 4*Math.random())*other.power;
						t.shield = Math.max(t.shield - Math.random()*2*other.power, 1);
					}
				}}
			],
			alarms:[
				{name:'hit_flash', code:function(t){
					if(!t.hit_rate) return t.reset_hit_rate();
					t.flash = !t.flash;
					t.hit_flash.time = Math.max((t.hit_rate--)/10, 1);
				}}
			]
		});

		Cont.instance_create();
		for(var ww = 0; ww < g.room.width/32; ww++){
			Wall.instance_create(32*ww + 16, 16);
			Wall.instance_create(32*ww + 16, g.room.height - 16);
		}
		for(var hh = 1; hh < g.room.height/32 - 1; hh++){
			Wall.instance_create(16, 32*hh + 16);
			Wall.instance_create(g.room.width - 16, 32*hh + 16);
		}
	}
};
	</script>
	</body>
</html>